1. hashmap: dictionary, keys to find the values
O(n) solution: hashmap
3. longest substring
methid1:all substring
method2:sliding windwos O(n)
method3: hashmap

17. Letter Combinations of a Phone Number
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        dict1 = {2:["a","b","c"],3:["d","e","f"],4:["g","h","i"],5:["j","k","l"],6:["m","n","o"],7:["p","q","r","s"],8:["t","u","v"],9:["w","x","y","z"]}
        list1 = [dict1[int(char)] for char in digits]
        def num_2(temp):
            result = []
            for i in temp[0]:
                for j in temp[1]:
                    result.append(i+j)
            return result
        def num_3(list1):
            temp = [list1[0],list1[1]]
            temp1 = num_2(temp)
            temp2 = [temp1,list1[2]]
            return num_2(temp2)
        
        if len(list1) == 1:
            return list1[0]
        if len(list1) == 2:
            return num_2(list1)
        if len(list1) == 3:
            return num_3(list1)
        if len(list1) == 4:
            temp = [list1[0],list1[1],list1[2]]
            temp1 = num_3(temp)
            temp2 = [temp1,list1[3]]
            return num_2(temp2)
            
17. rcursive solution (more advance):
class Solution:
    # @param {string} digits
    # @return {string[]}
    def letterCombinations(self, digits):
        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', 
                   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
        if len(digits) == 0:
            return []
        if len(digits) == 1:
            return list(mapping[digits[0]])
        prev = self.letterCombinations(digits[:-1])
        additional = mapping[digits[-1]]
        return [s + c for s in prev for c in additional]


30. Substring with Concatenation of All Words
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        length = len(words)*len(words[0])
        result = []
        for i in range(0,len(s)):
            start = s[i:(i+len(words[0]))]
            if start in words:
                temp = s[i:(i+length)]
                set1 = []
                for j in range(0,len(temp),len(words[0])):
                    set1.append(temp[j:(j+len(words[0]))])
                if sorted(set1) == sorted(words):
                    result.append(i)
        return result
