1. hashmap: dictionary, keys to find the values
O(n) solution: hashmap
3. longest substring
methid1:all substring
method2:sliding windwos O(n)
method3: hashmap

17. Letter Combinations of a Phone Number
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        dict1 = {2:["a","b","c"],3:["d","e","f"],4:["g","h","i"],5:["j","k","l"],6:["m","n","o"],7:["p","q","r","s"],8:["t","u","v"],9:["w","x","y","z"]}
        list1 = [dict1[int(char)] for char in digits]
        def num_2(temp):
            result = []
            for i in temp[0]:
                for j in temp[1]:
                    result.append(i+j)
            return result
        def num_3(list1):
            temp = [list1[0],list1[1]]
            temp1 = num_2(temp)
            temp2 = [temp1,list1[2]]
            return num_2(temp2)
        
        if len(list1) == 1:
            return list1[0]
        if len(list1) == 2:
            return num_2(list1)
        if len(list1) == 3:
            return num_3(list1)
        if len(list1) == 4:
            temp = [list1[0],list1[1],list1[2]]
            temp1 = num_3(temp)
            temp2 = [temp1,list1[3]]
            return num_2(temp2)
            
17. rcursive solution (more advance):
class Solution:
    # @param {string} digits
    # @return {string[]}
    def letterCombinations(self, digits):
        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', 
                   '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}
        if len(digits) == 0:
            return []
        if len(digits) == 1:
            return list(mapping[digits[0]])
        prev = self.letterCombinations(digits[:-1])
        additional = mapping[digits[-1]]
        return [s + c for s in prev for c in additional]


30. Substring with Concatenation of All Words
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        length = len(words)*len(words[0])
        result = []
        for i in range(0,len(s)):
            start = s[i:(i+len(words[0]))]
            if start in words:
                temp = s[i:(i+length)]
                set1 = []
                for j in range(0,len(temp),len(words[0])):
                    set1.append(temp[j:(j+len(words[0]))])
                if sorted(set1) == sorted(words):
                    result.append(i)
        return result
        
30. moving window solutions:
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        n = len(s)
        k = len(words)
        word_length = len(words[0])
        substring_size = word_length * k
        word_count = collections.Counter(words)
        
        def sliding_window(left):
            words_found = collections.defaultdict(int)
            words_used = 0
            excess_word = False
            
            # Do the same iteration pattern as the previous approach - iterate
            # word_length at a time, and at each iteration we focus on one word
            for right in range(left, n, word_length):
                if right + word_length > n:
                    break

                sub = s[right : right + word_length]
                if sub not in word_count:
                    # Mismatched word - reset the window
                    words_found = collections.defaultdict(int)
                    words_used = 0
                    excess_word = False
                    left = right + word_length # Retry at the next index
                else:
                    # If we reached max window size or have an excess word
                    while right - left == substring_size or excess_word:
                        # Move the left bound over continously
                        leftmost_word = s[left : left + word_length]
                        left += word_length
                        words_found[leftmost_word] -= 1

                        if words_found[leftmost_word] == word_count[leftmost_word]:
                            # This word was the excess word
                            excess_word = False
                        else:
                            # Otherwise we actually needed it
                            words_used -= 1
                    
                    # Keep track of how many times this word occurs in the window
                    words_found[sub] += 1
                    if words_found[sub] <= word_count[sub]:
                        words_used += 1
                    else:
                        # Found too many instances already
                        excess_word = True
                    
                    if words_used == k and not excess_word:
                        # Found a valid substring
                        answer.append(left)
        
        answer = []
        for i in range(word_length):
            sliding_window(i)

        return answer
        
 37. Sudoku Solver       
from collections import Counter
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        #each row:
        for row in board:
            row_temp = []
            for char in row:
                if char != ".":
                    row_temp.append(char)
            row_temp2 = Counter(row_temp)
            if any(i >1 for i in row_temp2.values()):
                return False
        #each column:
        for i in range(len(board[0])):
            col_temp = []
            for j in range(len(board)):
                if board[j][i] != ".":
                    col_temp.append(board[j][i])
            col_temp2 = Counter(col_temp)
            if any(i >1 for i in col_temp2.values()):
                return False
        #each 3*3:
        for i in range(3):
            for j in range(3):
                temp = []
                for row in range(i*3,i*3+3):
                    for col in range(j*3,j*3+3):
                        if board[row][col] != ".":
                            temp.append(board[row][col])
                temp2 = Counter(temp)
                if any(i >1 for i in temp2.values()):
                    return False
        return True
            
41. First Missing Positive
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        seen = set()
        output = 1
        for n in nums:
            seen.add(n)
            while output in seen:
                output += 1
        return output
41. O(N) time solution
def first(nums):
    nums.append(0)
    N  = len(nums)
    arr = [0 for _ in nums]
    for i in range(N):
        if 0<nums[i]<=N:
            arr[nums[i]-1] += 1
    for i in range(N):
        if arr[i] == 0: return i+1
            




